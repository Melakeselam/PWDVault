from functools import total_ordering
import os
import sys
from datetime import datetime, timedelta
from src.utils.DomainUtils import DomainUtils
import enum
from multipledispatch import dispatch
from src.service.PwdGenerator import PwdGenerator as Generator

@total_ordering
class PwdStatus(enum.Enum):
    CREATED = 0
    ACTIVE = 1
    SUSPENDED = 2
    YELLOW_EXPIRES_IN_10_DAYS = 3
    RED_EXPIRES_IN_3_DAYS = 4
    GREY_EXPIRED = 5

    def __lt__(self,other):
        if self.__class__ is other.__class__:
            return self.value < other.value
        return NotImplemented


class PasswordPattern:
    def __init__(self, pwd_size=16, pwd_min_num_req=1, pwd_min_upper_req=1, pwd_min_special_req=1, pwd_special_req=1) -> None:
        self._pwd_size = pwd_size
        self._pwd_min_num_req = pwd_min_num_req
        self._pwd_min_upper_req = pwd_min_upper_req
        self._pwd_min_special_req = pwd_min_special_req
        self._pwd_special_req = pwd_special_req

    def __str__(self) -> str:
        to_string = f'PasswordPattern[pwd_size:{self.pwd_size},pwd_min_num_req:\'{self.pwd_min_num_req}\',pwd_min_upper_req=pwd_min_upper_req:\'{self.pwd_min_upper_req}\',pwd_min_special_req:{self.pwd_min_special_req},pwd_special_req:{self.pwd_special_req}]'
        return DomainUtils.correct_obj_str_format(to_string)

    def pwd_size(self):
        return self._pwd_size

    def pwd_min_num_req(self):
        return self._pwd_min_num_req

    def pwd_min_upper_req(self):
        return self._pwd_min_upper_req

    def pwd_min_special_req(self):
        return self._pwd_min_special_req

    def pwd_special_req(self):
        return self._pwd_special_req


class Credentials:

    _host_id = -1
    _username = ''
    _password = ''
    _date_created = None
    _pwd_updated_date = None
    _pwd_expiration_date = None
    _pwd_pattern = None
    _status = None

    # constructors for different scenarios
    # 1. creating new credentials by user 
    #   1. pipe[from user to db]: 
    #       1. host_id -> -1 until inserted into db, 
    #       2. username supplied by user, 
    #       3. pwd -> auto generated using supplied pwd pattern, 
    #       4. creation & update dates -> today, 
    #       5. exp. date -> calculated from update date and supplied retention period, 
    #       6. status -> auto set as created
    #       7. pwd pattern supplied by user
    # 2. updating an existing credentials: 
    #   1. pipe[from db to user]: all data retrieved from db
    #   2. pipe[from user to db]: 
    #       1. host_id & created date doesn't change
    #       2. username update supplied by user, 
    #       3. pwd update triggered by user but autogenerated using supplied pwd pattern,
    #       4. pwd_update date triggered by pwd update event
    #       5. pwd_expiration_date autogenerated by pwd update event after pwd_update_date is updated
    #       6. pwd_pattern update supplied by user
    #       7. stats update scenarios
    #           1. user generates new pwd and sends activate command(pwd has been updated at the target host) -> ACTIVE
    #           2. user suspends host -> SUSPENDED
    #           3. system startup pwd check scenarios
    #               1. pwd_expiration_date between 10 to 3 days exclusive in the future -> YELLOW_EXPIRES_IN_10_DAYS
    #               2. pwd_expiration_date less than 3 days in the future -> RED_EXPIRES_IN_3_DAYS
    #               3. pwd_expiration_date is today or in the past -> GREY_EXPIRED
    #               4. pwd_expiration_date is more than a (config: ttl_host_with_expired_pwd) date in  the past -> SUSPENDED (automatically)
    # 3. retrieving host data
    #   1. pipe[from db to user for credentials display]:
    #       1. return host name, address, category name, platform name, username, password, pwd_expiration_date, status
    #   2. pipe[from db to user for for info update]:
    #       1. return all host info
    #   3. pipe[from db to system for critical passwords display]:
    #       1. return host id, host name, address, category, platform, status
    #       2. order by critical status, most critical first(use algorithm to order by vital attributes like target host's custom_retention_period is set, is update required by host, freqency of updates, etc )
    
    #used when inserting into db
    @dispatch(int,str, str, int, PwdStatus)
    def __init__(self, host_id, username, password, pwd_retention_in_days:int = 90, status = PwdStatus.CREATED) -> None:
        self._host_id = host_id
        self._username = username
        self._password = password
        self._date_created = datetime.today()
        self._pwd_updated_date = self._date_created
        self._pwd_expiration_date = self.calc_pwd_exp_date(pwd_retention_in_days)
        self._pwd_pattern = PasswordPattern()
        self._status = status

    #used when updating to or retrieving from db
    @dispatch(int, str, str, datetime, datetime, datetime, PasswordPattern, PwdStatus)
    def __init__(self, host_id, username, password, date_created:datetime, date_pwd_updated:datetime, date_pwd_expires:datetime, pwd_pattern, status=PwdStatus.CREATED) -> None:
        self._host_id = host_id
        self._username = username
        self._password = password
        self._date_created = date_created
        self._pwd_updated_date = date_pwd_updated
        self._pwd_expiration_date = date_pwd_expires
        self._pwd_pattern = pwd_pattern
        self._status = status

    #used when creating new
    @dispatch(int, str, datetime, datetime, datetime, PasswordPattern, PwdStatus)
    def __init__(self, host_id, username, date_created:datetime, date_pwd_updated:datetime, date_pwd_expires:datetime, pwd_pattern, status=PwdStatus.CREATED) -> None:
        self._host_id = host_id
        self._username = username
        self._password = self.generate_and_update_pwd(pwd_pattern)
        self._date_created = date_created
        self._pwd_updated_date = date_pwd_updated
        self._pwd_expiration_date = date_pwd_expires
        self._pwd_pattern = pwd_pattern
        self._status = status

    def __str__(self) -> str:
        to_string = f'Credentials[host_id:{self._host_id},user_name:\'{self._username}\',password:\'{self._password}\',date_created:\'{self._date_created}\',pwd_updated_date:\'{self._pwd_updated_date}\',pwd_expiration_date:{self._pwd_expiration_date},status:{self._status}]'
        return DomainUtils.correct_obj_str_format(to_string)

    @dispatch()
    def host_id(self):
        return self._host_id

    @dispatch()
    def username(self):
        return self._username

    @dispatch()
    def password(self):
        return self._password

    @dispatch()
    def date_created(self):
        return self._date_created

    @dispatch()
    def pwd_updated_date(self):
        return self._pwd_updated_date

    @dispatch()
    def pwd_expiration_date(self):
        return self._pwd_expiration_date

    @dispatch()
    def pwd_pattern(self):
        return self._pwd_pattern

    @dispatch()
    def status(self):
        return self._status

    @dispatch(int)
    def host_id(self, host_id:int):
        self._host_id = host_id

    @dispatch(str)
    def username(self, username:str):
        self._username = username

    @dispatch(str)
    def password(self,pwd):
        self._password = pwd

    @dispatch(datetime)
    def date_created(self,date:datetime):
        self._date_created = date

    @dispatch(datetime)
    def pwd_updated_date(self,date):
        self._pwd_updated_date = date

    @dispatch(int)
    def pwd_expiration_date_from_retention_period_in_days(self,days:int):
        self._pwd_expiration_date = self.calc_pwd_exp_date(days)

    @dispatch(PasswordPattern)
    def pwd_pattern(self,pattern:PasswordPattern):
        self._pwd_pattern = pattern

    @dispatch(PwdStatus)
    def status(self,status:PwdStatus):
        self._status = status

    def generate_and_update_pwd(self, pwd_pattern, pwd_retention_in_days):
        self._password = Generator.generatePassword(pwd_pattern)
        self._pwd_updated_date = datetime.today()
        self._date_pwd_expires = self.calc_pwd_exp_date(
            self._pwd_updated_date, pwd_retention_in_days)

    def calc_pwd_exp_date(self, retention_in_days):
        return self._pwd_updated_date + timedelta(days=retention_in_days)

    def validate_pwd_pattern(pwd_pattern):
        if type(pwd_pattern) is not dict or\
            'length' not in pwd_pattern.keys() or\
                type(pwd_pattern['length']) is not int or\
            'upper' not in pwd_pattern.keys() or\
            type(pwd_pattern['upper']) is not int or\
            'num' not in pwd_pattern.keys() or\
            type(pwd_pattern['num']) is not int or\
            'special' not in pwd_pattern.keys() or\
                type(pwd_pattern['special']) is not int:
            return False
        return True

    def _is_on_active_status(self) -> bool:
        return self._status == PwdStatus.ACTIVE or\
            self._status == PwdStatus.YELLOW_EXPIRES_IN_10_DAYS or\
            self._status == PwdStatus.RED_EXPIRES_IN_3_DAYS

    def _update_pwd_status(self):
        if not self._is_on_active_status():
            return False
        expiration_date_delta:datetime = self._pwd_expiration_date - datetime.today().date()
        if expiration_date_delta.days <= 0:
            self._status = PwdStatus.GREY_EXPIRED
        elif expiration_date_delta.days <= 3:
            self._status = PwdStatus.RED_EXPIRES_IN_3_DAYS
        elif expiration_date_delta.days <= 10:
            self._status = PwdStatus.YELLOW_EXPIRES_IN_10_DAYS
        return True

    def is_status(self, expected_status:PwdStatus) -> bool:
        return self._status == expected_status
    

    def activate(self):
        if self._status == PwdStatus.CREATED or self._status == PwdStatus.SUSPENDED:
            self._status = PwdStatus.ACTIVE
            return True
        elif self._status == PwdStatus.GREY_EXPIRED:
            print(f'Unable to activate... current Status is {self._status}')
            return False
        else:
            print(f'Unable to activate... current Status is {self._status}')
            return False

    def suspend(self):
        if self._is_on_active_status():
            self.status = PwdStatus.SUSPENDED
            return True
        else:
            print(f'Unable to suspend... current Status is {self._status}')
            return False
